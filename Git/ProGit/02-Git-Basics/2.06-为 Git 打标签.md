# 为 `Git` 打标签

> `Git` 可以给历史中的某一个提交打上标签以示重要，我们经常会使用这个功能来发布节点（比如：在 github 项目上的不同版本）

## 查看 `Git` 标签

> `git tag` 可以列出已有的标签
>
> -   `git tag -l '<value>'` 列出自己指定的标签

```shell
$ git tag -l '*Beta'
v0.0.1-Beta
v0.0.2-Beta
v0.0.3-Beta
v0.0.4-Beta
v0.0.5-Beta
v0.1.0-Beta
v0.1.1-Beta
v0.1.2-Beta
v0.1.3-Beta
v0.1.4-Beta
v0.1.5-Beta
v0.1.6-Beta
v0.1.7-Beta
```

## 为 `Git` 创建标签

> `Git` 使用两种主要类型的标签：轻量标签（ lightweight ） 与 附注标签（ annotated ）

### 附注标签（ annotated ）

> 附属标签是存储在 `Git` 数据库中的一个完整对象。它们是可以被校验的，其中包含标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard (GPG) 签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存哪些信息，轻量标签也是可用的。
>
> -   `git tag -a <tag-name> -m <tag-info>` 指令即可创建附注标签，如果不输入 `-m <tag-info>` 会弹出对话框，要求我们输入信息

```shell
$ git tag -a v3.0.0-beta -m 'v3* 版本第一次做标签！'
$ git tag -l v3*
v3.0.0-beta
```

### 轻量标签（ lightweight ）

> 轻量标签本质上是将提交校验和存储到一个文件中（没有保存任何信息）
>
> -   `git tag <tag-name>` 指令即可创建轻量标签

```shell
$ git tag v3.0.1
$ git tag -l v3*
v3.0.0-beta
v3.0.1-beta
```

### 为之前打标签

> 我们也可以对之前的提交打标签

1.  查看提交日子

```shell
$ git log --pretty=oneline -10
bacd77e3a80a77a247535895c2e04b6cdc0df1f1 (HEAD -> master, tag: v3.0.1-beta, tag: v3.0.0-beta) **/git/*/2.06-*.md first commit !
63146e2fd9bcf4bafd35bc47c7aa399f9e25bf43 commit **/git/*/2.05-*.md
b752db96da0f2b455bfee68289cb3ecee43ac585 (github-programmer/master) commit **/git/*/2.05-*.md
2fc7355a4b2b56dab00a9a8df74d80c6b7b7f64a commit **/git/*/2.05-*.md
9ccb3cc0ad5aa03cea1ade3db1df879727f16a72 使用 git pull 定位到了远程有变动，下载并替换了变动的文件 **/git/02-*/README.md Merge branch 'master' of https://github.com/linjialiang/programmer
16c3fa2c6a98ba7696d81f5c0098ee520744e91e 将所有数据提交上去
5b86805ded14efb53d97059291ad15288ef2e68f Update README.md
f407a9c967c6bd51c1039f6cc407e76eaddf8396 新增2个README.md文件
e80fe1659ef7e532fa309dbf5aad81d6758a3386 将所有数据提交上去
7f7a378e3855c804d9fee540530fc79c8c20dddf 使用了 git pull origin master --allow-unrelated-histories 指令，Merge branch 'master' of https://github.com/linjialiang/programmer
```

> 接下来我们为往前 10 次的提交打标签（提交 id 不必全部写上）

```shell
$ git tag -a v3.0.2-beta-old 7f7a378
$ git tag -l v3*
v3.0.0-beta
v3.0.1-beta
v3.0.2-beta-old
```

## 共享标签

> 默认情况下 `git push` 命令不会传送标签到远程仓库服务器上
>
> -   创建好标签后，我们必须显示的推送标签到共享服务器上
> -   推送指令与共享远程分支类似： `git push <remote-name> <tagname>`
> -   如果想要一次性推送所有不在远程仓库上的标签可以带上 `--tags` ，指令： `git push <remote-name> --tags`

```shell
$ git push github-programmer --tags
Counting objects: 14, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (14/14), 2.19 KiB | 449.00 KiB/s, done.
Total 14 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), completed with 3 local objects.
To https://github.com/linjialiang/programmer.git
 * [new tag]         v3.0.0-beta -> v3.0.0-beta
 * [new tag]         v3.0.1-beta -> v3.0.1-beta
 * [new tag]         v3.0.2-beta-old -> v3.0.2-beta-old
```

## 检出标签

> 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 `git checkout -b [branchname] [tagname]` 在特定的标签上创建一个新分支！
>
> -   注意：这么做你不必担心会出现问题，因为当我们切换到其它分支的时候，会发现数据又会恢复到从前的分支，不会有变动，这就是 Git 的神奇之处！

1.  获取远程仓库快照

    ```shell
    $ mkdir ../demo
    $ cd ../demo
    $ git init
    Initialized empty Git repository in D:/.git/
    $ git remote add github-demo https://github.com/linjialiang/programmer.git
    $ git pull github-demo
    remote: Counting objects: 774, done.
    remote: Compressing objects: 100% (148/148), done.
    remote: Total 774 (delta 127), reused 302 (delta 117), pack-reused 458
    Receiving objects: 100% (774/774), 208.06 KiB | 226.00 KiB/s, done.
    Resolving deltas: 100% (383/383), done.
    From https://github.com/linjialiang/programmer
     * [new branch]      dev        -> github-demo/dev
     * [new branch]      master     -> github-demo/master
     * [new tag]         v2.0.9     -> v2.0.9
     * [new tag]         v0.0.1-Beta -> v0.0.1-Beta
     * [new tag]         v0.0.2-Beta -> v0.0.2-Beta
     * [new tag]         v0.0.3-Beta -> v0.0.3-Beta
     * [new tag]         v0.0.4-Beta -> v0.0.4-Beta
     * [new tag]         v0.0.5-Beta -> v0.0.5-Beta
     * [new tag]         v0.1.0-Beta -> v0.1.0-Beta
     * [new tag]         v0.1.1-Beta -> v0.1.1-Beta
     * [new tag]         v0.1.2-Beta -> v0.1.2-Beta
     * [new tag]         v0.1.3-Beta -> v0.1.3-Beta
     * [new tag]         v0.1.4-Beta -> v0.1.4-Beta
     * [new tag]         v0.1.5-Beta -> v0.1.5-Beta
     * [new tag]         v0.1.6-Beta -> v0.1.6-Beta
     * [new tag]         v0.1.7-Beta -> v0.1.7-Beta
     * [new tag]         v1.0.0      -> v1.0.0
     * [new tag]         v1.0.1      -> v1.0.1
     * [new tag]         v2.0.0      -> v2.0.0
     * [new tag]         v2.0.1      -> v2.0.1
     * [new tag]         v2.0.10     -> v2.0.10
     * [new tag]         v2.0.2      -> v2.0.2
     * [new tag]         v2.0.3      -> v2.0.3
     * [new tag]         v2.0.4      -> v2.0.4
     * [new tag]         v2.0.5      -> v2.0.5
     * [new tag]         v2.0.6      -> v2.0.6
     * [new tag]         v2.0.7      -> v2.0.7
     * [new tag]         v2.0.8      -> v2.0.8
     * [new tag]         v3.0.0-beta -> v3.0.0-beta
    You asked to pull from the remote 'github-demo', but did not specify
    a branch. Because this is not the default configured remote
    for your current branch, you must specify a branch on the command line.
    ```

2.  将特定标签，检出未新的仓库分支

    ```shell
    $ git checkout -b v2 v2.0.10
    Switched to a new branch 'v2'
    $ ls
    _config.yml  LICENSE  other/   README.md     tp5/
    editor/      lnamp/   phpcms/  shadowsocks/
    ```
