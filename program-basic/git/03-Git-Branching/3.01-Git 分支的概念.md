# Git 分支的概念

## Git 是如何处理分支的？

> 为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。

### Git 保存数据的方式

> Git 会保存一个提交对象 `commit object` 。
>
> -   提交对象会包含一个指向暂存内容快照的指针，并且该提交对象还包含了：
> -   1) 作者的姓名和邮箱
> -   2) 提交时输入的信息
> -   3) 以及制定它的父对象的指针（首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象！）

### 举例说明 Git 保存数据的方式

> 本节正在编辑，还未完成，但是我现在有事情需要出去下，为了防止意外发生，我准备将本小节做 Git 提交（暂存和提交文件的过程）
>
> -   为了更加形象的说明我再新建 2 个文件： `3.00-demo1.md` `3.00-demo2.md`

```shell
$ cd */git/03*
$ touch 3.00-demo{1,2}.md
$ git status -s
?? 3.00-demo1.md
?? 3.00-demo2.md
?? 3.01-Git 分支的概念.md
```

> 现在我们可以看到 3 个从未暂存过的文件
>
> -   使用 `git add` 暂存操作时，会为每一个文件计算校验和（使用之前提到过的 `SHA-1` 哈希算法）；然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 BLOB 对象来保护它们）
> -   最终，将校验和加入到暂存区域等待提交！
> -   `BLOB 对象` ：这是二进制大对象，是一个可以存储二进制文件的容器，典型的 `BLOB 对象` 如，一张图片或一个声音文件。

```shell
$ git add 3.00-*.md 3.01-*.md
$ git status -s
A  3.00-demo1.md
A  3.00-demo2.md
A  "3.01-Git 分支的概念.md"
```

> 当使用 `git commit` 进行提交操作时
>
> 1.  Git 会先计算每一个子目录的校验和，
> 2.  然后在 Git 仓库中这些 `校验和` 保存为 `树对象`
> 3.  随后， Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含了指向这个树对象的指针。
> 4.  如此一来，当我们需要的时候，Git 就可以重现这次保存的快照了！
> 5.  两个 demo 文件，是测试我们，我们这里就不提交了

```shell
$ git rm -f 3.00-demo*.md
rm 'program-basic/git/03-Git-Branching/3.00-demo1.md'
rm 'program-basic/git/03-Git-Branching/3.00-demo2.md'
$ git commit -m '首次提交 **/git/*/3.01-*.md'
[master 1a1454f] 首次提交 **/git/*/3.01-*.md
 1 file changed, 7 insertions(+), 1 deletion(-)
```

>  现在，Git 仓库中新增了5个对象：
>
> 1.  三个 BLOB 对象（保存着文件快照）
> 2.  一个树对象（记录着目录结构和 BLOB 对象所有）
> 3.  一个提交对象（包含着指向前述树对象的指针和所有提交者信息）

```shell
$ git status -s
```

> 操作成功后， `git status` 应该查看不到状态，下面我们做些修改后再次提交，会怎样呢？
>
> -   这次产生的提交对象会包含一个指向上次提交的对象（父对象）指针。如何理解呢：
> -   假设我们一共提交的三次 `快照A（首次提交）` `快照B（2次）` `快照C（3次）` ：
> -   `快照A` 没有父对象
> -   `快照B` 有一个父对象 `快照A`
> -   `快照C` 有一个父对象 `快照B`

## Git 分支到底是什么呢？

> Git 的分支，本质上仅仅是指向提交对象的可变指针。
>
> -   Git 的默认分支是 `master`，我们进行了多次的提交操作后，其实已经有一个指向最后那个提交对象的 `master 分支` ,它会在每次的提交操作中自动向前移动
>     注意：Git 的 `master 分支` 并不是一个特殊分支，它跟其它分支完全没有区别，只是因为 `git init` 命令默认创建的分支名就是 `master` ， 并且大多数人都没有去改动它！

## 操作分支

### 创建分支 & 切换分支

> 我们可以用 `git branch <branch-name>` 创建分支

```shell
$ git branch test
$ git branch
* master
  testing
$ git checkout testing
Switched to branch 'testing'
$ touch **/git/03-*/demo.md
$ vim **/git/*/demo.md
git branch testing
git checkout testing
$ git add **/git/*/demo.md
$ git commit -m '在testing分支上新建了 test.md 并提交'
```

> 接下来我们切换回 `master 分支` ，我们会发现 demo.md 文件消失了，我们新建它，并填写内容

```shell
$ git checkout master
$ touch **/git/03-*/demo.md
$ vim **/git/*/demo.md
git checkout master
$ git add **/git/*/demo.md
$ git commit -m '切换回 master 分支后，test.md 消失了，我们重新新建了该文件，并 做了修改'
```

> 现在我们使用 `git checkout <branch-name>` 来回切换，会发现，demo.md的内容会在 `最后一次提交` 和 `倒数第二次提交` 之间来回变化

-   我们可以通过 `git log` 指令查看所有分支的指向以及项目的分支分叉情况

```shell
$ git log --oneline --decorate --graph --all -5
* 3aac152 (HEAD -> master) 切换回 master 分支后，test.md 消失了，我们重新新建了
该文件，并做了修改
| * f5c3963 (testing) 在testing分支上新建了 test.md 并提交
|/
* 7516ee5 commit **/git/*/2.03-*.md
* 6b92749 (github-programmer/master) 提交 **/git/*/3.01-*.md
* 870fc93 提交 **/git/*/3.01-*.md
```

### 如何删除分支？

> Git 的分支实质上仅仅是包含所指对象的校验和（长度为 40 的 SHA-1 值的字符串）的文件，所以创建和销毁都异常高效。创建一个新分支就相当于往一个文件中写入 41 个字节 （ 40 个字符和 1 个换行符），所以速度非常快！
>
> -   同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。
> -   拥有这些高效的特性，所以 Git 官方一直在鼓励开发人员频繁地创建和使用分支！
> -   之前的 `testing` 分支是比较糟糕的，我们仅仅为了测试而已，现在可以删除了

```shell
$ git branch --delete testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
```

> 好像提示我们分支并没有完全合并，那好吧，我们先合并下
>
> -   使用 `git merge <branch-name>` 可以合并分支

```shell
$ git merge testing
Auto-merging program-basic/git/03-Git-Branching/test.md
CONFLICT (add/add): Merge conflict in program-basic/git/03-Git-Branching/test.md
Automatic merge failed; fix conflicts and then commit the result.
```

> 好像又遇到了问题，程序说合并时 `**/git/*/test.md` 文件出现了冲突，我们使用 `git status` 来查看下状态先：

```shell
$ git status
On branch master
Your branch is ahead of 'github-programmer/master' by 2 commits.
  (use "git push" to publish your local commits)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

        both added:      program-basic/git/03-Git-Branching/test.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   program-basic/git/03-Git-Branching/3.01-Git 分支的概念.md

no changes added to commit (use "git add" and/or "git commit -a")
```

> 忽略部分无关内容(1,4都和本次无关)不讲，上面的意思是说：
>
> 1.  当前分支快照比远程仓库`master`分支快了2个版本，你可以使用 `git push` 来发布本地提交
> 2.  有未合并（ `ummerged` ）的内容，可以使用 `git merge --abort` 指令来中止合并
> 3.  未合并的处理后，使用 `git add <file>...` 加入暂存区，用 `git commit` 来提交到仓库
> 4.  有已修改文件，你可以使用 `git add <file>...`来加入暂存区，如果放弃本次的修改可以使用 `git checkout -- <file>...` 指令

```shell
$ vim test.md
<<<<<<< HEAD
git checkout master
=======
git branch testing
git checkout testing
>>>>>>> testing
```

> 打开 test.md 以后会发现内容是这样显示的，我们可以选取我们需要的，删除掉不要的，或者自己重新写都是可以的，写好后再用 `git add` `git commit` 来提交，当然这里我们不需要 test.md
> - 提示：如果我们以后使用 atom 做编辑器， `merge conflict` 会是 Git 合并利器，当然这是后话了！

```shell
$ git status -s
 M "3.01-Git 分支的概念.md"
AA test.md
$ git -f test.md
$ git add 3.02-*.md
$ git commit -m '提交了 */git/*/3.01-*.md'
```
