# 记录每次更新到仓库

> 现在我们手上有了一个真实项目的 `Git 仓库` ，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。
> 请记住，你工作目录下的每一个文件都不外乎2种属性： `已跟踪文件` 或 `未跟踪文件` 。
>
> -   `已跟踪文件` ：已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的几率，在工作一段时间后，他们的状态可能处于这 3 种状态： `未修改` 、 `已修改` 、 `已存存放入暂存区`
> -   `未跟踪文件` ：工作目录中除了已跟踪文件以外的所有其他文件都属于未跟踪文件，它们既不存在与上次快照的记录中，也没有放入暂存区。
> -   初次克隆某个仓库的时候，工作目录中的所有文件都属于 `已跟踪文件` ，并处于未修改状态。
> -   如果是在空白目录或已有项目上，通过 `git init` 指令创建仓库，所有新建文件或已有文讲都属于 `未跟踪文件` ，和克隆过来的刚好相反

## 如何检测当前文件状态？

> 在写项目的时候，我们需要一次次提交文件，我们就会遇到这个问题，如何查看项目文件所处于的状态？
>
> -   使用指令 `git status` 命令，可以查看项目文件处于睡眠状态

1.  如果在克隆仓库后立即使用此命令，会看到类似这样的输出：

```shell
$ git status
On branch master
nothing to commit, working directory clean
```

> 说明现在的工作目录相当干净：
>
> 1.  所有已跟踪文件在上次提交后都未被更改过
> 2.  此外当前目录下没有出现任何处于未跟踪状态的新文件
> 3.  当前所在分支名是 `master` （master 是 Git 的默认分支名）,并且与远程对应的分支没有偏离！

2.  如果在已有项目上新建的仓库，立即使用此命令，会看到类似这样的输出：

```shell
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        README.md
        program-basic/
        program-language/
        program-other/

nothing added to commit but untracked files present (use "git add" to track)
```

> -   `On branch master` 说明当前所在分支名是 `master`
> -   `No commits yet` 说明文件该项目从未提交过
> -   `Untancked files:` 列出了项目当前类别下未跟踪的文件名及子目录名，并且告诉我们使用 `git add <file> ...` 跟踪新文件的方法。

3.  如果在空白目录中新建仓库，立即使用此命令。会看到类似这样的输出：

```shell
$ git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

> -   该输出与上面的类似，只是因为是空白目录，并没有未跟踪的文件及子目录

## 跟踪新文件

> 使用命令 `git add README.md` 开始跟踪一个文件，并使用 `git status` 来查看状态
>
> -   `git status` 查看工作目录当前列表下所有文件及子目录的状态
> -   `git status <file>...` 查看工作目录指定的个别文件或子目录的状态

```shell
$ git add README.md
...
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        program-basic/
        program-language/
        program-other/
```

> 这里又出现了一些新知识点
>
> -   `Changes to be committed:` 说明该项目出现了 `已跟踪文件` ，并且处于已暂存状态；
> -   为了担心我们这次操作是失误，紧接着 `Git` 又告诉我们可以通过 `git rm --cached README.md` 指令将 `README.md` 从已暂存区域移除（因为我们从未提交（git commit）过该文件， 从已暂存区域移除后相当于重新回到了 `未跟踪状态`）
> -   `new file:   README.md` 说明 `README.md` 文件是新增加到 `已跟踪文件` 的（之前属于 `未跟踪文件` ）

## 暂存已修改文件

> 现在我们来修改一个已被跟踪的文件，就用本小节文件来做测试。
>
> -   由于我们这个项目很多文件名都是中文命名的，会出现乱码的现象，下面我们就先来解决 `Git` 中文乱码问题（并不是乱码，只是被 quote 了）

### 如何处理 `Git` 中文假乱码（其实只是被 `quote` ）

> 假乱码的出现，是因为 git 对 0x80 以上的字符进行 quote ，只需要执行下面这段代码即可

```shell
$ git config --global core.quotepath = false
```

### 暂存已修改文件前

> 中文文件实在太长不利于描写，以后很多地方会以 `*` 代理中文部分
>
> -   虽然我这里省略的，但是你们在真实操作时，请不要随意省略，因为用上 `*` 很有可能会提交多个文件

```shell
$ git add program-basic/git/02-Git-Basics/2.02-记录每次更新到仓库.md
$ git commit -m '第一次 提交了 2.02-记录每次更新到仓库.md 文件 !'
$ cd program-basic/git/02-Git-Basics/
$ echo '新增内容' >> 2.02-记录每次更新到仓库.md
```

> 然后使用 `git status` 会看到下面的内容：

```shell
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   2.02-记录每次更新到仓库.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../editor/
        ../01-Getting-Started/
        2.01-获取 Git 仓库.md
        README.md
        ../README.md
        ../../linux/
        ../../../program-language/
        ../../../program-other/

no changes added to commit (use "git add" and/or "git commit -a")
```

> 文件 `2.02-记录每次更新到仓库.md` 出现在 `Changes not staged for commit:` 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。如果要暂存这次更新，需要运行 `git add 2.02-*.md` 命令。

### `git add` 命令有什么用？

> `git add` 这个命令，我们几乎每次操作都需要使用到，这个有什么样的作用呢？
>
> -   可以用它开始跟踪新文件；
> -   可以把已跟踪的文件放到暂存区
> -   还能用于合并时把冲突的文件标记为已解决状态
>     我们应该将这个命令理解为 `添加内容到下一次提交中` 而不是 `将一个文件添加到项目中`。

### 暂存已修改文件后

```shell
$ git add 2.02-*.md
```

> 然后在使用 `git status` 会看到下面的内容：

```shell
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   2.02-记录每次更新到仓库.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   2.02-记录每次更新到仓库.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../editor/
        ../01-Getting-Started/
        2.01-获取 Git 仓库.md
        README.md
        ../README.md
        ../../linux/
        ../../../program-language/
        ../../../program-other/
```

> 同学们是不是感觉很不可思议，`2.02-*.md` 同时出现在了暂存区和废暂存区。这是为什么？
>
> -   实际上 `Git` 只不过暂存了我运行 `git add` 命令之前的版本，而我在使用 `git add` 指令后，又写了一段代码，结果就是这样了。
>     如果不明白，记得开启脑壳思考思考呗，下面我来看看 `git add` 后应该出现的情况：

```shell
$ git add 2.02-*.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   2.02-记录每次更新到仓库.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        ../../editor/
        ../01-Getting-Started/
        2.01-获取 Git 仓库.md
        README.md
        ../README.md
        ../../linux/
        ../../../program-language/
        ../../../program-other/
```

## git 状态能简化吗？

> `git status` 是查看 git 状态的指令，但是同学们是不是会感觉它很复杂？
>
> -   不知道你们具体想法，但在写这本书的过程中，我确实感觉到，状态简化输出的重要性。
> -   git 状态简化输出后，虽然会少很多说明，但是会让老手感觉更加简洁
> -   立志帮助大家在看完这本书后直接成为 `Git 老手` ， 所以以后没有必要，都只会输出简化状态

### `git 状态简化` 该怎么写？

> `git status -s` 这是最实用的的 `git 状态简化` 写法
>
> -   下面我们来看看效果：

```shell
$ git status -s
A  "2.01-获取 Git 仓库.md"
MM 2.02-记录每次更新到仓库.md
AM README.md
?? ../../editor/
?? ../01-Getting-Started/
?? ../README.md
?? ../../linux/
?? ../../../program-language/
?? ../../../program-other/
```

1.  `MM` 干啥子用的？

    > -   第 1 列 <font color="green">M</font> 指文件状态 `已暂存`
    > -   都 2 列 <font color="red">M</font> 指文件状态 `已修改`
    > -   如果一个文件存在两个 `M` ，说明在使用 `git add` 命令暂存后该文件又新增了数据

2.  `A` 干啥子用的？

    > <font color="green">A</font> 和第一个 <font color="green">M</font> 类似，指文件状态 `已暂存`
    >
    > -   `A` 跟 `第一列M` 的区别在于，`A` 代表该文件状态 `已暂存` 但从未提交过，对 `未跟踪文件` 使用 `git add` 指令后的结果
    > -   `A` 只会出现在一个列

3.  `??` 这又是什么意思？
    > <font color="red">??</font> 两个英文问号，指该文件属于 `未跟踪文件`

## 忽略文件

> 当前这个项目是一本书，理论上所有文件都会提交上去，但是如果我们写的是一个网站项目，我们就不可能将自己服务器上数据库暴露出来了，这样我们就希望可以将某些文件忽略掉，
>
> -   在 `Git` 里想要忽略文件，不让它提交，是很方便的，
> -   在项目根目录下创建 `.gitignore` 文件，一行一个配置项，支持一些简单的正则表达式
> -   感觉自己不知道该怎么写的同学，直接去这里抄吧： <https://github.com/github/gitignore>
> -   下面贴下我们这个项目忽略的文件，记得提交上去
> -   我们要养成一开始就设置好 `.gitignore` 文件的习惯，以免将来误提交这类无用的文件。

```shell
$ cd /d/programmer
$ touch
$ vim .gitignore
```

```.gitignore
# 所有空格或者以 # 开头的行都会被 Git 忽略
# 可以使用标准的 glob 模式匹配
# 匹配 glob 模式可以以 / 开头防止递归
# 匹配 glob 模式可以以 / 结尾指定目录
# 要忽略指定模式意外的文件或目录，可以在模式前面加上感叹号 ! 取反
# glob 模式，指的是 shell 所使用的简化了的正则表达式，规则如下：
    # 1. 星号 * 匹配 0 个或多个任意字符；
    # 2. [abd] 要嘛匹配 a，要嘛匹配 b，要嘛匹配 c；
    # 3. 问好 ? 只匹配一个任意字符；
    # 4. [0-9] 表示匹配所有 0 到 9 的数字组合；
    # 5. a/**/z 表示可以匹配 a/z a/b/z a/b/c/z 等（两个星号 * 匹配任意中间目录）；

# 使用 vim 编辑器可能会产生的不提交文件：
    # Swap
    [._]*.s[a-v][a-z]
    [._]*.sw[a-p]
    [._]s[a-v][a-z]
    [._]sw[a-p]

    # Session
    Session.vim

    # Temporary
    .netrwhist
    *~
    # Auto-generated tag files
    tags
```

## 查看已暂存和为暂存的修改
> `git status` 命令输出是比较模糊，如果我们想知道具体修改了什么地方，可以用 `git diff` 命令。我们通过可以用 `git diff` 来解决两个问题
> - 当前做的哪些更新还没有暂存？
> - 有哪些更新已经暂存起来准备好了下次提交？
> 虽然 `git status` 已经模糊的解答了，但是 `git diff` 可以显示具体哪些行发生了改变！
> - `git diff` 查看尚未暂存的文件更新了哪些部分；
> - `git diff --staged` 查看已暂存的将要添加到下次提交里的内容。

## 提交更新
> 提交更新很容易，有 3 种方式：
> - `git commit` 会启动文本编辑器一遍输入本次提交的说明
> - `git commit -v` 在 `git commit` 的基础上，在编辑器输出本次所有改变的内容
> - `git commit -m '写入提交说明'`

## 跳过使用暂存区域
> 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。
> - `Git` 提供了一个跳过使用暂存区域的方式，只要在提交的时候，使用 `git commit -a` 命令， `Git` 就会自动把所有已经跟踪过的文件暂存起来一并提交， 从而跳过 `git add` 步骤：
